#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""docstring."""

from pathlib import Path
from pprint import pprint
import os

from io import StringIO
from contextlib import redirect_stdout
from collections.abc import Iterable

import jupytext
from nbconvert.preprocessors.execute import ExecutePreprocessor
import nbformat

from Bio.Restriction import CommOnly as Co

from pydna.amplify import pcr
from pydna.readers import read
from pydna.parsers import parse_primers
from pydna.assembly import Assembly
from pydna.dseqrecord import Dseqrecord
from pydna.amplicon import Amplicon
from pydna.primer import Primer

from pathvalidate import ValidationError, validate_filename

try:
    from importlib.resources import files
except ImportError:  # for Python 3.8
    from importlib_resources import files

from ypkpathway.pth import Pth

ypkfiles = accessory_file_paths


tu = {"name": "na",
      "backbone": Dseqrecord("", id="na", name="backbone"),
      "parts": [Amplicon("",
                         id="pYPKa_Z_",
                         name="promoter",
                         forward_primer=Primer("",
                                               name="577_crp585-557"),
                         reverse_primer=Primer("",
                                               name="567_pCAPsAjiIF")),
                Amplicon("",
                         id="pYPKa_A_",
                         name="gene",
                         forward_primer=Primer("",
                                               name="468_pCAPs_release_fw"),
                         reverse_primer=Primer("",
                                               name="467_pCAPs_release_re")),
                Amplicon("",
                         id="pYPKa_E_",
                         name="terminator",
                         forward_primer=Primer("",
                                               name="568_pCAPsAjiIR"),
                         reverse_primer=Primer("",
                                               name="578_crp42-70")), ],
      "primer_file_path": Pth("standard_primers.fasta", "."),
      "template_file_path": Pth("nb_tu.py", (ypkfiles,)),
      "workdir": Path(""),
      "datadirs": [Path(""), ],
      "accessory_file_paths": [Pth(p, (ypkfiles,)) for p in ("tu.png",
                                                             "logo.png")]}


class TranscriptionalUnit:
    """docstring."""

    def __init__(self,
                 name: str = "",
                 workdir: Path = Path("."),
                 datadirs: Iterable[Path] = (Path("."),),
                 structure: dict = tu):
        try:
            # The name has to be a valid filename
            validate_filename(name, check_reserved=True)
        except ValidationError as e:
            raise e

        if "." in name:
            raise Exception("dot (.) not permitted in name")

        backbone, *elements = name.split("_")

        if len(elements) != 3:
            raise ValueError("Name has to indicate a backbone, a promoter "
                             "a gene and a terminator; four elements "
                             "separated by underscore (_). "
                             f"Not: {name}")
            
        self.__dict__.update(structure)
        self.name = name
        self.backbone.id = backbone
        self.workdir = Path(workdir)/name
        try:
            self.workdir.mkdir(parents=True)
        except FileExistsError:
            
        self.datadirs = [Path(d) for d in datadirs]
        assert all(d.is_dir() for d in self.datadirs)
        self.primer_file_path = self.workdir/self.primer_file_path
        self.template_file_path = str(self.workdir)/self.template_file_path
        for i, (elementname, element) in enumerate(zip(elements, self.parts)):
            element.id += elementname
        for i, p in enumerate(self.accessory_file_paths):
            self.accessory_file_paths[i] = str(self.workdir)/p

    def collect(self, copy_to_dir=True):
        """docstring."""
        primer_path = self.primer_file_path
        primer_path.copy_to_dir()
        pd = {x.name: x for x in parse_primers(primer_path)}

        for i, element in enumerate(self.parts):
            name = element.id
            p = Pth((self.workdir/name).with_suffix(".gb"), self.datadirs)
            p.copy_to_dir()
            element.template = read(p)
            element.forward_primer = pd.get(element.forward_primer.name)
            element.reverse_primer = pd.get(element.reverse_primer.name)
            self.parts[i] = pcr(element)

        p = Pth((self.workdir/self.backbone.id).with_suffix(".gb"), self.datadirs)
        p.copy_to_dir()
        bbs = read(p)
        f = self.parts[0].forward_primer
        r = self.parts[-1].reverse_primer
        mcs = pcr(f, r, bbs)[len(f):-len(r)]
        eb = mcs.unique_cutters(Co) & bbs.unique_cutters(Co)
        enzymes = [b for a, b in sorted(
              [(abs(len(f1)-len(f2)), e) for ((f1, f2), e) in
               [(mcs.cut(e), e) for e in eb]])]
        bbs.annotations["comment"] += f"\n\nLinearized with {enzymes[0]}"
        self.backbone = bbs

        if copy_to_dir:
            for obj in self.__dict__.values():
                if hasattr(obj, "copy_to_dir"):
                    obj.copy_to_dir()
                if isinstance(obj, Iterable) and not isinstance(obj, (dict, str, bytes)):
                    for elm in obj:
                        if hasattr(elm, "copy_to_dir"):
                            elm.copy_to_dir()
                    


    def __repr__(self):
        """docstring."""
        return self.name

    @property
    def status(self):
        """docstring."""
        pprint(self.__dict__, sort_dicts=False)

    def format_code(self):
        """docstring."""
        py = self.template_path.read_text().format(
                                            name=repr(self),
                                            backbone=self.paths["backbone"].stem,
                                            enz=self.enzyme,
                                            promoter=self.paths["promoter"].stem,
                                            gene=self.paths["gene"].stem,
                                            terminator=self.paths["terminator"].stem,
                                            **self.primers["names"])

        nb = jupytext.reads(py, fmt='py:percent')

        assert nbformat.validate(nb) is None
        
        return nb, py
    
    def execute_py(self):
        """docstring."""
        for p in self.accessory_file_paths:
            _copy2(p, self.workdir)
        self.copy_primers()
        self.copy_sequence_files()
        globs = {}
        nb, py = self.format_code()
        cwd = Path.cwd()
        os.chdir(self.workdir)
        f = StringIO()
        with redirect_stdout(f):
            exec(py, globs)
        s = f.getvalue()        
        os.chdir(cwd)
        name = Path(self.workdir/self.paths["fn"]).with_suffix(".py").write_text(py)
        return s

    def execute_nb(self):
        """docstring."""

        self.copy_primers()
        self.copy_sequence_files()
        nb, py = self.format_code()
        ep = ExecutePreprocessor()
        ep.timeout = 60  # seconds
        ep.interrupt_on_timeout = True
        output = ""
        resources = {'metadata': {'path': self.workdir, 
                                  "stdout": output}}
        nb_executed, resources = ep.preprocess(nb, 
                                               resources=resources)
        
        nbformat.write(nb, (self.workdir/self.paths["fn"]).with_suffix(".ipynb"))
        
        return resources

    def assemble(self):
        prom = self.pcr_products["promoter"]
        gene = self.pcr_products["gene"]
        term = self.pcr_products["terminator"]

        prom.name = self.paths["promoter"].stem[-4:]
        gene.name = self.paths["gene"].stem[-4:]
        term.name = self.paths["terminator"].stem[-4:]

        linear_backbone = self.files["backbone"].linearize(self.enzyme)

        asm = Assembly((linear_backbone, prom, gene, term), limit=31)

        candidates = asm.assemble_circular()

        candidate, *rest = candidates

        candidate.cseguid() == rest[0].cseguid()

        fp_prom = self.primers[self.primernames["fp_prom"]]

        return candidate.synced(fp_prom), candidate.figure()


if __name__ == "__main__":

    workdir = "/home/bjorn/Desktop/python_packages/ypkpathway/src/ypkpathway"

    datadirs = (
        "/home/bjorn/Desktop/mec@githb/YeastPathwayKit/sequences",
        "/home/bjorn/Desktop/mec@githb/YeastPathwayKitPrivate/sequences",)

    name = "pYPK0_PDC1_KlLAC4_PGI1"

    self = TranscriptionalUnit(name, workdir, datadirs)

    # self.find_primers()
    # self.copy_primers()
    # self.read_primers()

    # self.find_sequence_files()
    # self.copy_sequence_files()
    # self.read_sequence_files()

    # self.find_enzymes()

    # self.pcr()

    # self.format_code()

    # self.execute_nb()
    





